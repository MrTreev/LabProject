---
author: Oliver Patterson (S3723206), Kaizhe Huang (S3686152)
date: "21/05/2022"
fontsize: 10pt
header-includes:
    - \usepackage{csquotes}
    - \usepackage[australian]{babel}
    - \usepackage{booktabs}
    - \usepackage{dcolumn}
    - \usepackage{wrapfig}
    - \usepackage{subcaption}
    - \usepackage{caption}
    - \usepackage{graphicx}
    - \graphicspath{{Images}}
    - \usepackage{float}
    - \usepackage{fancyhdr}
    - \usepackage{keyval}
    - \usepackage{siunitx}
    - \floatplacement{figure}{H}
    - \floatplacement{table}{H}
    - \usepackage{tikz}
    - \usepackage{tikz-timing}
documentclass: "article"
geometry: margin=2cm
output:
    pdf_document:
        fig_caption: yes
        fig_height: 3
        fig_width: 4.5
        latex_engine: pdflatex
        number_sections: yes
        citation_package: "biblatex"
bibliography: referencing/cites.bib
biblio-style: ieee
nocite: '@*'
---
\pagestyle{empty}

\begin{centering}

\vspace{5 cm}

\Huge

{\bf Advanced Digital Design 1 \\ (EEET2162) \\ Laboratory Project }

\vspace{4 cm}

\Large

Oliver Patterson (S3723206)\\
Kaizhe Huang (S3686152)

\vspace{4 cm}

\normalsize

\vspace{0.5 cm}

Laboratory Demonstrator: \\
Genevieve Fahey

\vspace{0.5 cm}

Date: \\
21/05/2022

\vspace{4 cm}

\normalsize

RMIT School of \\
Engineering

\end{centering}
\newpage
\pagenumbering{roman}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\setlength{\headheight}{15pt}
\fancyhf{}
\fancyhead[L]{Laboratory Project}
\fancyhead[R]{Oliver Patterson \& Kaizhe Huang}
\fancyfoot[C]{\thepage}
\clearpage
\pagenumbering{roman}
# Executive Summary {-}

\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}

# Introdution \label{Intro}

In this project, an FPGA design is created for the DE-10 Nano development board to be capable of displaying custom images to an HDMI monitor. The design is developed with Quartus Prime and written in Verilog HDL.

The initial goal of the project was to allow the FPGA to receive video data from a controller software running on the hard processor, and forwards such video to an HDMI monitor. However, due to time constraint and technical difficulty, the goal of the project is reduced to only displaying images hardcoded within the FPGA.

# Literature Search \label{Literature}

## DE-10 Nano

The DE-10 Nano development board is based a Cyclone V SoC FPGA. Relavant components include:

* A Field-Programmable Gate Array (FPGA), this is the main focus of this project.
* A Hard Processor System (HPS) based on ARM Cortex-A9 architecture.
* An ADV7513 HDMI transmittor IC.
* A built-in USB-Blaster programmer for the FPGA.
* A Micro-SD card slot, allowing an OS to be loaded to the HPS.

## ADV7513 \label{ADV7513}

This HDMI transmittor IC simplifies the logic required to output a valid HDMI video signal. The IC, configurable via I\textsuperscript{2}C, supports vairous HDMI resolutions and colour formats. When correctly configured, ADV7513 receives a video signal from the FPGA, and outputs it through an HDMI connector, where it is interpreted by an HDMI monitor.

The input signals are:

* Colour data (D[23:0])
* Data enable (DE)
* Hsync
* VSync
* Clock

\begin{figure}
	\centering
	\begin{tikzpicture}[x=0.015cm, y=-0.015cm, every node/.style={font={\sffamily}}]
		\draw (0, 0) rectangle (800, 525);
		\fill[orange!10!white] (16, 10) rectangle (656, 490);
		\fill[gray] (704, 0) rectangle (800, 525);
		\fill[gray] (0, 523) rectangle (800, 525);
		\draw (16, 0) -- (16, 525);
		\draw (656, 0) -- (656, 525);
		\draw (0, 10) -- (800, 10);
		\draw (0, 490) -- (800, 490);
		\node at (336, 250) {Frame data};
		\draw[|-|,thick,blue] (0, 0) -- node [above] {Horizontal front porch} (16, 0);
		\draw[|-|,thick,blue] (656, 0) -- node [above,xshift=-1.4cm] {Horizontal back porch} (704, 0);
		\draw[|-|,thick,black] (704, 0) -- node [above,xshift=0.6cm] {Horizontal sync} (800, 0);
		\draw[|-|,thick,blue] (0, 0) -- node [left] {Vertical front porch} (0, 10);
		\draw[|-|,thick,blue] (0, 490) -- node [left] {Vertical back porch} (0, 523);
		\draw[|-|,thick,black] (0, 523) -- node [left,yshift=-0.2cm] {Vertical sync} (0, 525);
	\end{tikzpicture}
	\caption{Video signal timing graph}
	\label{VideoTimingGraph}
\end{figure}

\begin{figure}
	\centering
	\begin{tikztimingtable}[timing/wscale=0.2]
		D[23:0] & 5{X 12{D} 7{X}} 100{X} 2{X 12{D} 7{X}} \\
		DE      & 5{L 12{H} 7{L}} 100{L} 2{L 12{H} 7{L}} \\
		Hsync   & 12{15{H} 5{L}} \\
		Vsync   & 140{H} 40{L} 60{H} \\
	\end{tikztimingtable}
	\caption{Video signal timing waveform}
	\label{VideoTimingWave}
\end{figure}

Each pixel is sent left-to-right, by scanlines, top-to-bottom, in each clock cycle. Figure \ref{VideoTimingGraph} shows the timings required for one frame. Each frame starts in a vertical front porch for the first several scanlines, where no data is sent. Then scalines containing frame data is sent. Followed by a vertical back porch, where no data is sent, and a vertical sync period, where a Vsync signal is asserted low. Each scanline starts in a horizotal front porch, where no data is sent, then data corresponding to this scanline is sent. Followed by a horizontal back porch, where no data is sent, and a horizontal sync period, where a Hsync signal is asserted low.

Outside of the front and back porches and syncing periods, DE is asserted high, and D[23:0] will contain the colour of the current pixel. D[23:0] may be in many colour formats, depending on the configurations made via I\textsuperscript{2}C, but the simpliest format is RGB, where each of the red, blue and green colour components are encoded in 8-bit unsigned integers.

Figure \ref{VideoTimingWave} shows an example of the video signals. It sends 5 scanlines, in between are (respectively) the horizontal back porches, horizontal sync periods, and horizontal front porches. The signal then enters a vertical back porch, a vertical sync period, and a vertical front porch, before start sending the next frame.

For this project, a video mode of $640 \times 480$ @ \SI{60}{Hz} is used, as it is simple and supported by most (if not all) monitors. This mode requires the video signal timings described in Table \ref{Video480Timing}.

\begin{table}
	\hfill
	\begin{tabular}{lr}
		\hline
		\multicolumn{2}{c}{Horizontal} \\
		\hline
		Front porch & 16 \\
		Sync width & 96 \\
		Back porch & 48 \\
		Active pixels & 640 \\
		Total pixels & 800 \\
		\hline
	\end{tabular}%
	\hfill
	\begin{tabular}{lr}
		\hline
		\multicolumn{2}{c}{Vertical} \\
		\hline
		Front porch & 10 \\
		Sync width & 2 \\
		Back porch & 33 \\
		Active pixels & 480 \\
		Total pixels & 525 \\
		\hline
	\end{tabular}%
	\hspace{\fill}
	\caption{Display timings for $640 \times 480$ @ \SI{60}{Hz}}
	\label{Video480Timing}
\end{table}

% TODO: I2C configs needed, source taken from Terasic demo

\begin{table}
	\centering
	\begin{tabular}{lll}
		\hline
		Register Address & Register Value & Note \\
		\hline
		'h98 & 'h03 & Must be set to 0x03 for proper operation \\
		'h01 & 'h00 & Set 'N' value at 6144 \\
		'h02 & 'h18 & Set 'N' value at 6144 \\
		'h03 & 'h00 & Set 'N' value at 6144 \\
		'h14 & 'h70 & Set Ch count in the channel status to 8 \\
		'h15 & 'h20 & Input 444 (RGB or YCrCb) with Separate Syncs, 48kHz fs \\
		'h16 & 'h30 & Output format 444, 24-bit input \\
		'h18 & 'h46 & Disable CSC \\
		'h40 & 'h80 & General control packet enable \\
		'h41 & 'h10 & Power down control \\
		'h49 & 'ha8 & Set dither mode - 12-to-10 bit \\
		'h55 & 'h10 & Set RGB in AVI infoframe \\
		'h56 & 'h08 & Set active format aspect \\
		'h96 & 'hf6 & Set interrup \\
		'h73 & 'h07 & Info frame Ch count to 8 \\
		'h76 & 'h1f & Set speaker allocation for 8 channels \\
		'h98 & 'h03 & Must be set to 0x03 for proper operation \\
		'h99 & 'h02 & Must be set to Default Value \\
		'h9a & 'he0 & Must be set to 0b1110000 \\
		'h9c & 'h30 & PLL filter R1 value \\
		'h9d & 'h61 & Set clock divide \\
		'ha2 & 'ha4 & Must be set to 0xA4 for proper operation \\
		'ha3 & 'ha4 & Must be set to 0xA4 for proper operation \\
		'ha5 & 'h04 & Must be set to Default Value \\
		'hab & 'h40 & Must be set to Default Value \\
		'haf & 'h14 & Select HDMI mode \\
		'hba & 'h60 & No clock delay \\
		'hd1 & 'hff & Must be set to Default Value \\
		'hde & 'h10 & Must be set to Default for proper operation \\
		'he4 & 'h60 & Must be set to Default Value \\
		'hfa & 'h7d & Nbr of times to look for good phase \\
		\hline
	\end{tabular}
	\caption{ADV7513 registers needed to be set}
	\label{ADVRegisters}
\end{table}

## Running Linux on the DE-10 Nano \label{LinuxOnDE10}

\textcite{DE10Web} provides an image that can be flashed onto a Micro-SD card. Powering-on the DE-10 Nano while the Micro-SD card is insert boots a Linux distribution, Angstr√∂m Linux, on the HPS.

The boot process is fascillitated by U-Boot. U-Boot may configure the FPGA, where it can later be accessed by device drivers on Linux, and then loads the Linux kernel from the SD card. By default, U-Boot configures the FPGA to be a graphical interface for Linux. This can be modified so that the FPGA is loaded with a custom firmware.

% TODO: share memory between FPGA and Linux

# Technical Work and Results \label{TechWork}

## Overview \label{TechOverview}

Appendices \ref{TLE} to \ref{PixelStream} list all Verilog code implementing the FPGA design. Among them, the top-level entity (TLE) contains plumbing for the other modules, depicted in Figure \ref{ModulesOverview}.

\begin{figure}
	\centering
	\includegraphics{ModulesOverview}
	\caption{Overview of all modules}
	\label{ModulesOverview}
\end{figure}

## ClockDividerPow2

Clock dividers are needed to reduce the frequency of the \SI{50}{MHz} built-in FPGA clock. Specifically, there are 2 slower clocks needed:

* The I\textsuperscript{2}C interface of ADV7513 does not function with a high frequency, therefore the clock is divided by 4096 into \SI{12.20703125}{kHz} before being used by the I\textsuperscript{2}C controller.
* According to Table \ref{Video480Timing}, the total number of pixels each frame is $800 \times 525 = 420000$, which means there are $420000 \times 60 = 25200000$ pixels every second, which requires a \SI{25.2}{MHz} clock. This can be approximated by dividing the built-in clock by 2 to obtain a \SI{25}{MHz} clock.

The module ClockDividerPow2 divides an input clock by a factor of $2^n$, where $n$ is a parameter. This is implemented by an $n$-bit counter that increses by 1 at each rising clock edge. The MSB of the counter is treated as the output clock, whose frequency will then be

$$f_\text{out} = \frac{f_\text{in}}{2^n}$$

The clock divider used to be able to divide clocks by an arbitrary factor, where the output is produced by comparing the counter content to half of the dividing factor. However, doing so appears to prompt difficult-to-track issues, thus the design is simplified to only divide by a power of 2.

## PixelCursor

## PixelAddr

## PixelStream

## I2CSubsystem

This module is composed of 2 submodules, I2CController and I2CDataFeed.

I2CController receives an Op[1:0] signal specifying what to do to the bus (Table \ref{OpMeanings}), and a byte of data (Data[7:0]) to be sent. The module maintains a state machine with 35 states, with each state corresponding to some output SDA and SCL (Figure \ref{I2CControllerStateOutput}). State transitions occur on every rising clock edge, some of which depends on the value of Op[1:0] (Figure \ref{I2CControllerStateDiagram}).

\begin{table}
	\centering
	\begin{tabular}{lll}
		\hline
		Op[1:0] & Name & Description \\
		\hline
		00 & STOP & Stop the I\textsuperscript{2}C transaction, release the bus, or keep it released. \\
		01 & START & Start a I\textsuperscript{2}C transaction, or repeat start the transaction without releasing the bus. \\
		10 & CONTINUE & Continue sending the the next byte within the ongoing transaction. \\
		11 & RESTART & Stop and start the I\textsuperscript{2}C transaction, releasing the bus in the process. \\
		\hline
	\end{tabular}
	\caption{Meanings of the Op[1:0] signal in I2CSubsystem}
	\label{OpMeanings}
\end{table}

\begin{figure}
	\centering
	\begin{tikztimingtable}[timing/wscale=5]
		state & [Z] D{IDLE} D{START\_0} D{START\_1} D{START\_2} D{BIT7\_0} D{BIT7\_1} D{BIT7\_2} D{BIT6\_0} D{BIT6\_1} D{BIT6\_2} D{BIT5\_0} D{BIT5\_1} 0Z \\
		SDA & H HLL 3D{Data[7]} 3D{Data[6]} 2D{Data[5]} \\
		SCL & H HHL LHL LHL LH 0L \\
		\\
		state & [Z] D{BIT5\_2} D{BIT4\_0} D{BIT4\_1} D{BIT4\_2} D{BIT3\_0} D{BIT3\_1} D{BIT3\_2} D{BIT2\_0} D{BIT2\_1} D{BIT2\_2} D{BIT1\_0} D{BIT1\_1} 0Z \\
		SDA & D{Data[5]} 3D{Data[4]} 3D{Data[3]} 3D{Data[2]} 2D{Data[1]} \\
		SCL & L LHL LHL LHL LH 0L \\
		\\
		state & [Z] D{BIT1\_2} D{BIT0\_0} D{BIT0\_1} D{BIT0\_2} D{ACK\_0} D{ACK\_1} D{ACK\_2} D{REPEAT\_0} D{STOP\_0} D{STOP\_1} D{STOP\_2} 0Z \\
		SDA & D{Data[1]} 3D{Data[0]} 3Z H LLH \\
		SCL & L LHL LHL L LHH \\
	\end{tikztimingtable}
	\caption{Output of I2CController corresponding to each state}
	\label{I2CControllerStateOutput}
\end{figure}

\begin{figure}[p]
	\centering
	\scalebox{0.5}{\input{Images/I2CControllerStates.latex}}
	\caption{State diagram of I2CController}
	\label{I2CControllerStateDiagram}
\end{figure}

Additionally, I2CController outputs an output Completed, which is high only when the state is ACK_1, indicating the transfer of a byte is completed.

I2CDataFeed provides the Op[1:0] and Data[7:0] signals that I2CController needs, they are also determined by a state machine. On reset, its state is 0, where Op[1:0] is STOP, thus keeping the I2CController in idle. When an Update signal is received, it progresses to the next state, looping back to state 0 after the last state. This state machines contains 94 states, with all other states besides 0 containing some non-STOP Op[1:0] and a byte of Data[7:0], they list the sequence of data that that needs to be sent in order to configure the ADV7513 IC.

The Update input of I2CDataFeed is connected to the Completed output, forming a feedback loop: When a byte transfer is completed, I2CController notifies I2CDataFeed to update its Op[1:0] and Data[7:0], then I2CController carries out the next operation. When I2CDataFeed reaches state 0, the loop stops. This also means that both state machines will stay idle upon reset, therefore an external stimulus from a button is also connected to Update. When I2CDataFeed is in state 0 and BTN0 on the DE-10 Nano is pressed, it enters state 1, instructing I2CController to start the feedback loop.

For each register that needs to be set within the ADV7513, 5 steps are involved:

1. Start an I\textsuperscript{2}C transaction.
2. Send the slave address of the ADV7513, which is set 'h72 on the DE-10 Nano.
3. Send the register address.
4. Send the value to be written to the register.
5. Stop the I\textsuperscript{2}C transaction.

To set the registers listed in Table \ref{ADVRegisters}, I2CDataFeed contains the states partially listed in Table \ref{I2CDataFeedStates}, which produces Figure \ref{I2CSubsystemWave}, the omitted states can be easily inferred by referencing Table \ref{ADVRegisters}.

\begin{table}[H]
	\centering
	\begin{tabular}{rll}
		\hline
		State & Op[1:0] & Data[7:0] \\
		\hline
		0 & STOP & 'h00 \\
		1 & START & 'h72 (slave address) \\
		2 & CONTINUE & 'h98 (first register address) \\
		3 & CONTINUE & 'h03 (first register value) \\
		4 & RESTART & 'h72 (slave address) \\
		5 & CONTINUE & 'h01 (second register address) \\
		6 & CONTINUE & 'h00 (second register value) \\
		7 & RESTART & 'h72 (slave address) \\
		\multicolumn{3}{c}{$\vdots$} \\
		93 & CONTINUE & 'h7d (last register value) \\
		\hline
	\end{tabular}
	\caption{Partial list of states within I2CDataFeed}
	\label{I2CDataFeedStates}
\end{table}

\begin{figure}
	\centering
	\begin{tikztimingtable}[timing/wscale=0.3]
		Start button & 9L 3H 168L \\
		Completed & 37L H 26L H 26L H 32L H 26L H 26L H 2L \\
		I2CDataFeed state & 9D{0} 28D{1} 27D{2} 27D{3} 33D{4} 27D{5} 27D{6} 2D{} \\
		Op[1:0] & 9D{STOP} 28D{START} 27D{CONTINUE} 27D{CONTINUE} 33D{RESTART} 27D{CONTINUE} 27D{CONTINUE} 2D{}\\
		Data[7:0] & 9D{'h00} 28D{'h72} 27D{h'98} 27D{'h03} 33D{'h72} 27D{'h01} 27D{'h00} 2D{} \\
		SDA & 9H HLL 3L3H3H3H3L3L3H3L3Z 3H3L3L3H3H3L3L3L3Z 3L3L3L3L3L3L3H3H3Z LLHHLL 3L3H3H3H3L3L3H3L3Z 3L3L3L3L3L3L3L3H3Z 24L3Z \\
		SCL & 9H HHL 27{LHL} LHHHHL 27{LHL} \\
	\end{tikztimingtable}
	\caption{Operation of I2CSubsystem}
	\label{I2CSubsystemWave}
\end{figure}

## Scrapped Work

\newpage
# References
\printbibliography[heading=none]
\def\printbibliography{}

\newpage
# Appendices
## Top Level Entity \label{TLE}
\scriptsize
```{verilog, eval=FALSE}
module Project(
	// Buttons
	input BTN0,						// Button I2C Trigger
	input RST_N,					// Button Reset

	// Clocks
	input FPGA_CLK1_50,				// Clock 50MHz FPGA

	// From ADV7513
	// To ADV7513
	output			ADV_DE,			// ADV Data Enable
	output			ADV_CLK,		// ADV Video Clock
	output	[23:0] 	ADV_D,			// ADV Video Data
	output			ADV_Hsync,		// ADV Horizontal Sync
	output			ADV_Vsync,		// ADV Vertical Sync
	inout			ADV_SDA,		// ADV Serial Port Data
	output			ADV_SCL,		// ADV Serial Port Data Clock

	// GPIO for debugging
	output [19:0] GPIO_1
);

	// Define Wires
	wire		pix_clk;
	wire		frame;
	wire		i2c_clk;
	wire		hsync;
	wire		vsync;
	wire	[9:0]	pix_x;
	wire	[9:0]	pix_y;
	wire	[15:0]	pix_addr;

	// Define Registers
	reg		i2c_start = 0;

	// Direct Assignments
	assign ADV_Hsync = ~hsync;
	assign ADV_Vsync = ~vsync;

	// Configure Clocks, ADV leads pix_clk by 90 degrees
	ClockDividerPow2 #(1) div_pix_clk(FPGA_CLK1_50,RST_N,pix_clk);
	ClockDividerPow2 #(1) div_adv_clk(~FPGA_CLK1_50,RST_N,ADV_CLK);
	ClockDividerPow2 #(12) i2c_clkdiv(FPGA_CLK1_50,RST_N,i2c_clk);

	// Configure Hsync, Vsync, ADV_DE, And Pixel x and y values
	PixelCursor pixel_cursor(
		pix_clk,
		RST_N,
		pix_x,
		pix_y,
		ADV_DE,
		hsync,
		vsync
	);

	// Get Pixel Address from x and y values
	PixelAddr PixAddr(
		pix_x,
		pix_y,
		pix_addr,
		frame
	);

	// Get Pixel Value from Pixel Address
	PixelStream PixStream(pix_addr,ADV_D);

	// Synchronous button press trigger for I2C
	always @(posedge(i2c_clk))
    	i2c_start <= ~BTN0;

	// I2C Configuration
	I2CSubsystem i2c(
    	.Start(i2c_start),
    	.Clock(i2c_clk),
    	.Reset_n(RST_N),
    	.SDA(ADV_SDA),
    	.SCL(ADV_SCL)
	);
endmodule
```

\newpage
## I2C Controller Module \label{I2CController}
```{verilog, eval=FALSE}
module I2CController (
	input [7:0] Data,
	input [1:0] Op,
	input Clock,
	input Reset_n,

	// Indicate one byte transfer has completed, upstream should update Data and Op
	// Op and Data are only expected to update when state is IDLE or when Completed rises
	output Completed,

	inout SDA,
	output SCL
);

localparam OP_STOP			= 2'd0;	// Stop indefinately
localparam OP_START			= 2'd1;	// Send start or repeat start signal
localparam OP_CONTINUE		= 2'd2;	// Continue sending data
localparam OP_RESTART		= 2'd3;	// Stop the transaction and start a new one
localparam STATE_IDLE 		= 6'd00;
localparam STATE_START_0 	= 6'd01;
localparam STATE_START_1 	= 6'd02;
localparam STATE_START_2 	= 6'd03;
localparam STATE_BIT7_0 	= 6'd04;
localparam STATE_BIT7_1 	= 6'd05;
localparam STATE_BIT7_2 	= 6'd06;
localparam STATE_BIT6_0 	= 6'd07;
localparam STATE_BIT6_1 	= 6'd08;
localparam STATE_BIT6_2 	= 6'd09;
localparam STATE_BIT5_0 	= 6'd10;
localparam STATE_BIT5_1 	= 6'd11;
localparam STATE_BIT5_2 	= 6'd12;
localparam STATE_BIT4_0 	= 6'd13;
localparam STATE_BIT4_1 	= 6'd14;
localparam STATE_BIT4_2 	= 6'd15;
localparam STATE_BIT3_0 	= 6'd16;
localparam STATE_BIT3_1 	= 6'd17;
localparam STATE_BIT3_2 	= 6'd18;
localparam STATE_BIT2_0 	= 6'd19;
localparam STATE_BIT2_1 	= 6'd20;
localparam STATE_BIT2_2 	= 6'd21;
localparam STATE_BIT1_0 	= 6'd22;
localparam STATE_BIT1_1 	= 6'd23;
localparam STATE_BIT1_2 	= 6'd24;
localparam STATE_BIT0_0 	= 6'd25;
localparam STATE_BIT0_1 	= 6'd26;
localparam STATE_BIT0_2 	= 6'd27;
localparam STATE_ACK_0 		= 6'd28;
localparam STATE_ACK_1 		= 6'd29;
localparam STATE_ACK_2 		= 6'd30;
localparam STATE_REPEAT_0 	= 6'd31;
localparam STATE_STOP_0 	= 6'd32;
localparam STATE_STOP_1 	= 6'd33;
localparam STATE_STOP_2 	= 6'd34;

reg [5:0] state = STATE_IDLE;

always @(posedge(Clock), negedge(Reset_n))
begin
	if (~Reset_n)
		state <= STATE_IDLE;
	else begin
		case (state)
			STATE_IDLE:
				state <= Op == OP_START ? STATE_START_0 : STATE_IDLE;
			STATE_ACK_2:
				case (Op)
					OP_START:
						state <= STATE_REPEAT_0;
					OP_CONTINUE:
						state <= STATE_BIT7_0;
					default:
						state <= STATE_STOP_0;
				endcase
			STATE_REPEAT_0:
				state <= STATE_START_0;
			STATE_STOP_2:
				state <= Op == OP_RESTART ? STATE_START_0 : STATE_IDLE;
			default:
				state <= state + 6'b000001;
		endcase
	end
end
reg sdar = 1; // register for SDA output
reg sda_en = 0; // if SDA should output or be high-Z
reg sclr = 1; // rergister for SCL
assign SDA = sda_en ? sdar : 1'bz; // tristate SDA
assign SCL = sclr;
assign Completed = state == STATE_ACK_1;

always @(state, Data)
begin
	case (state)
		STATE_IDLE: begin
			sdar <= 1;
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_START_0: begin
			sdar <= 1;
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_START_1: begin
			sdar <= 0;
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_START_2: begin
			sdar <= 0;
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT7_0: begin
			sdar <= Data[7];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT7_1: begin
			sdar <= Data[7];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT7_2: begin
			sdar <= Data[7];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT6_0: begin
			sdar <= Data[6];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT6_1: begin
			sdar <= Data[6];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT6_2: begin
			sdar <= Data[6];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT5_0: begin
			sdar <= Data[5];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT5_1: begin
			sdar <= Data[5];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT5_2: begin
			sdar <= Data[5];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT4_0: begin
			sdar <= Data[4];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT4_1: begin
			sdar <= Data[4];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT4_2: begin
			sdar <= Data[4];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT3_0: begin
			sdar <= Data[3];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT3_1: begin
			sdar <= Data[3];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT3_2: begin
			sdar <= Data[3];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT2_0: begin
			sdar <= Data[2];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT2_1: begin
			sdar <= Data[2];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT2_2: begin
			sdar <= Data[2];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT1_0: begin
			sdar <= Data[1];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT1_1: begin
			sdar <= Data[1];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT1_2: begin
			sdar <= Data[1];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT0_0: begin
			sdar <= Data[0];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_BIT0_1: begin
			sdar <= Data[0];
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_BIT0_2: begin
			sdar <= Data[0];
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_ACK_0: begin
			sdar <= 0;
			sda_en <= 0;
			sclr <= 0;
		end
		STATE_ACK_1: begin
			sdar <= 0;
			sda_en <= 0;
			sclr <= 1;
		end
		STATE_ACK_2: begin
			sdar <= 0;
			sda_en <= 0;
			sclr <= 0;
		end
		STATE_REPEAT_0: begin
			sdar <= 1;
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_STOP_0: begin
			sdar <= 0;
			sda_en <= 1;
			sclr <= 0;
		end
		STATE_STOP_1: begin
			sdar <= 0;
			sda_en <= 1;
			sclr <= 1;
		end
		STATE_STOP_2: begin
			sdar <= 1;
			sda_en <= 1;
			sclr <= 1;
		end
		default: begin
			sdar <= 1;
			sda_en <= 1;
			sclr <= 1;
		end
	endcase
end

endmodule
```

\newpage
## I2C Data Feed Module \label{I2CDataFeed}
```{verilog, eval=FALSE}
module I2CDataFeed (
	input Update,
	input Reset_n,
	output reg [1:0] Op = 0,
	output reg [7:0] Data = 0
);

localparam OP_STOP			= 2'd0;	// Stop indefinately
localparam OP_START			= 2'd1;	// Send start or repeat start signal
localparam OP_CONTINUE		= 2'd2;	// Continue sending data
localparam OP_RESTART		= 2'd3;	// Stop the transaction and start a new one

localparam SLAVE_ADDR		= 8'h72; // or 'h7A ?

reg [6:0] state = 0;

always @(posedge(Update), negedge(Reset_n))
begin
	if (~Reset_n)
		state <= 0;
	else begin
		case (state)
			93: // The last state
				state <= 0;
			default:
				state <= state + 1'b1;
		endcase
	end
end

always @(state)
begin
	case (state)
		0: begin
			Op <= OP_STOP;
			Data <= 0;
		end
		1: begin
        	Op <= OP_START;
        	Data <= SLAVE_ADDR;
        end
        2: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h98;
        end
        3: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h03;
        end
        4: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        5: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h01;
        end
        6: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h00;
        end
        7: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        8: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h02;
        end
        9: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h18;
        end
        10: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        11: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h03;
        end
        12: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h00;
        end
        13: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        14: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h14;
        end
        15: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h70;
        end
        16: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        17: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h15;
        end
        18: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h20;
        end
        19: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        20: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h16;
        end
        21: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h30;
        end
        22: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        23: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h18;
        end
        24: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h46;
        end
        25: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        26: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h40;
        end
        27: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h80;
        end
        28: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        29: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h41;
        end
        30: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h10;
        end
        31: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        32: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h49;
        end
        33: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hA8;
        end
        34: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        35: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h55;
        end
        36: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h10;
        end
        37: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        38: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h56;
        end
        39: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h08;
        end
        40: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        41: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h96;
        end
        42: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hF6;
        end
        43: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        44: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h73;
        end
        45: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h07;
        end
        46: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        47: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h76;
        end
        48: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h1f;
        end
        49: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        50: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h98;
        end
        51: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h03;
        end
        52: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        53: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h99;
        end
        54: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h02;
        end
        55: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        56: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h9a;
        end
        57: begin
        	Op <= OP_CONTINUE;
        	Data <= 'he0;
        end
        58: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        59: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h9c;
        end
        60: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h30;
        end
        61: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        62: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h9d;
        end
        63: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h61;
        end
        64: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        65: begin
        	Op <= OP_CONTINUE;
        	Data <= 'ha2;
        end
        66: begin
        	Op <= OP_CONTINUE;
        	Data <= 'ha4;
        end
        67: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        68: begin
        	Op <= OP_CONTINUE;
        	Data <= 'ha3;
        end
        69: begin
        	Op <= OP_CONTINUE;
        	Data <= 'ha4;
        end
        70: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        71: begin
        	Op <= OP_CONTINUE;
        	Data <= 'ha5;
        end
        72: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h04;
        end
        73: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        74: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hab;
        end
        75: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h40;
        end
        76: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        77: begin
        	Op <= OP_CONTINUE;
        	Data <= 'haf;
        end
        78: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h14;
        end
        79: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        80: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hba;
        end
        81: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h60;
        end
        82: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        83: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hd1;
        end
        84: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hff;
        end
        85: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        86: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hde;
        end
        87: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h10;
        end
        88: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        89: begin
        	Op <= OP_CONTINUE;
        	Data <= 'he4;
        end
        90: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h60;
        end
        91: begin
        	Op <= OP_RESTART;
        	Data <= SLAVE_ADDR;
        end
        92: begin
        	Op <= OP_CONTINUE;
        	Data <= 'hfa;
        end
        93: begin
        	Op <= OP_CONTINUE;
        	Data <= 'h7d;
        end
		default: begin
			Op <= OP_STOP;
			Data <= 0;
		end
	endcase
end

endmodule
```

\newpage
## I2C Subsystem Module \label{I2CSubsystem}
```{verilog, eval=FALSE}
module I2CSubsystem (
	// Per Hardware User Guide:
	// > The user should wait 200ms for the address to be decided
	// Therefore I2CSubsystem does not start running upon reset, but instead
	// waits for a Start signal, which may come from software or button.
	input Start,
	input Clock, // Slow clock for I2C
	input Reset_n,

	inout SDA,
	output SCL
);

wire controller_completed;

wire update_data = Start | controller_completed;
//reg update_data = 0;
//always @(posedge(Clock), negedge(Reset_n))
//begin
//	if (~Reset_n)
//		update_data <= 0;
//	else
//		update_data <= Start | controller_completed;
//end

wire [7:0] data;
wire [1:0] op;

I2CController controller (
	.Data(data),
	.Op(op),
	.Clock(Clock),
	.Reset_n(Reset_n),
	.Completed(controller_completed),
	.SDA(SDA),
	.SCL(SCL)
);

I2CDataFeed data_feed (
	.Update(update_data),
	.Reset_n(Reset_n),
	.Op(op),
	.Data(data)
);

endmodule
```

\newpage
## Clock Divider Module \label{ClockDividerPow2}
```{verilog, eval=FALSE}
module ClockDividerPow2 #(parameter POWER)(

	input clk_in,
	input reset_n,
	output clk_out
);

reg [POWER-1:0] counter_value = 0;

always @(posedge(clk_in), negedge(reset_n))
begin
	if (~reset_n)
		counter_value <= 0;
	else
		counter_value <= counter_value + 1'b1;
end

assign clk_out = counter_value[POWER-1];

endmodule
```

\newpage
## Pixel Address Module \label{PixelAddr}
```{verilog, eval=FALSE}
module PixelAddr(

	input	[9:0]	xpos,
	input	[9:0]	ypos,
	output	[15:0]	address,
	output	[7:0]	frameOut

);

	reg		[15:0]	addr	= 16'b0;
	reg		[15:0]	offset	= 16'b0;
	reg		[5:0]	frame	= 05'b0;

	always @(*)
	begin
		if (xpos < 10'd640 && ypos < 10'd480)
		begin
			addr <= (ypos/10'd4) * 10'd160 + (xpos/10'd4) + offset;
		end
		else if (ypos==10'd524)
		begin
			if (frame < 5'h10)
			begin
				offset <=  16'h4b00;
				frame <= frame + 5'h01;
			end
			else
			begin
				offset <= 16'b0;
				frame <= frame + 5'h1;
			end
		end
		else
		begin
			addr <= 16'b1;
		end
	end

	assign frameOut = (frame < 5'h10);
	assign address = addr;

endmodule
```

\newpage
## Pixel Cursor Module \label{PixelCursor}
```{verilog, eval=FALSE}
module PixelCursor (
	input pix_clk,	// 25 MHz
	input reset_n,
	output reg [9:0] hcount = 0,
	output reg [9:0] vcount = 0,
	output active,
	output hsync,
	output vsync
);

always @(posedge(pix_clk), negedge(reset_n)) begin
	if (~reset_n) begin
		hcount <= 0;
		vcount <= 0;
	end else begin
		if (hcount == 799) begin
			hcount <= 0;
			if (vcount == 524)
				vcount <= 0;
			else
				vcount <= vcount + 1'b1;
		end else
			hcount <= hcount + 1'b1;
	end
end

assign active = hcount < 640 && vcount < 480;
assign hsync = hcount >= 688 && hcount < 784;
assign vsync = vcount >= 513 && vcount < 515;

endmodule
```

\newpage
## Pixel Stream (Memory Stream) Module \label{PixelStream}
```{verilog, eval=FALSE}
module PixelStream(

	input	[15:0]	address,
	output	[23:0]	pixel

);
	// Define Registers
	reg [23:0] memory [38399:0];
	reg [23:0] value;

	// Initialise all registers
	initial
	begin
		value = 24'b0;
		$readmemh("PixStream.mem",memory);
	end

	always @(*)
	begin
		value <= memory[address];
	end
	assign pixel = value;
endmodule
```
